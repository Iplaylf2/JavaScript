# proto

ES中的对象都保留着原型的引用。
当对象访问一个自身没有的属性时，会试图从原型中访问该属性。
而原型也是一个对象。如果在原型中仍然没找到该属性，将试图从原型的原型中访问……

![](../../images/TIM截图20170726084225.jpg)

因为其链表的结构，所以被称为原型链。

chrome浏览器环境中的原型是在对象属性上显式的实现，以下的例子通过对__proto__属性访问改变对象的原型。
但这在真正的编程环境中是不被推荐的，因为不是所有的浏览器都有__proto__的实现。

~~~
var foo = {};
var prototype = {
    name: 'I in prototype.'
};
foo.__proto__ = prototype;
console.dir(foo.name);//I in prototype.
~~~

# Function

对一个Function类对象使用**new**关键字，可以构造一个指定原型的对象。
而这种方式所指定的原型，是该Function类对象的**prototype**属性。

~~~
var classA = function () { };
classA.prototype = { name: 'I in prototype.' };

var foo = new classA();
console.dir(foo.name);//I in prototype.
~~~

这种使用一个函数对象A构造出另一个对象B的行为，被称为类的实例化。
A为B的类，B为A的实例。

使用**instanceof**关键字可以判断一个对象是否为一个函数对象的实例。

~~~
foo instanceof classA;//true
~~~

实际上instanceof判断的是，一个对象的原型链中其中一个原型是否为另一个函数对象的prototype。

~~~
var mock = function () { };
mock.prototype = classA.prototype;

foo instanceof mock;//true
~~~

该实例确实能通过原型链使用该类提供的属性，所以instanceof的语义并没有发生变化，A instanceof B仍然是判断A是否为B的实例。

值得一提的是Function对象由其本身构造。

~~~
Function.prototype === Function.__proto__;//true;不恰当的例子。
~~~


# Object

Function对象的prototype属性也是一个对象，该prototype是由Object对象构造的。

~~~
Function.prototype.__proto__ === Object.prototype;//true;不恰当的例子
~~~

ES的对象，要不由Object构造，要不由Function类的函数对象构造。
因此在ES中，任何对象都是Object的实例。

~~~
Function instanceof Object
Number instanceof Object
new Number() instanceof Object
~~~

那么Object是由谁构造的?
Object也是一个函数对象，所以他由Function对象构造的。

~~~
Object.__proto__ === Function.prototype;//true;不恰当的例子
~~~







