# ===

===运算符用于比较两个值的相等。
这个值就是指原始值以及引用值。

因此，会有以下结论：

* 不同类型的比较，返回false。
* 相同原始类型的值比较时，值相等返回true，值不等返回false。
* 相同类型(class)的对象比较时，则比较他们是否指向同一个对象。

~~~
var foo = {};
foo === {};//false
~~~

而!==相当于===的结果取反。

# ==

当==运算符用于两种不同类型的值时，不会直接返回false，而是会发生类型转换，再进行相等的比较。

* 比较不同原始类型的值时，会进行类型转换，再进行===的比较。
注：在实现上，原始类型的值都会一致转换成Number数值。

~~~
0 == '0';//true;
~~~

* 比较一个值和一个对象时，则将对象转换成该值的原始类型，再进行===的比较。
注：对象可以通过重写toString/valueOf函数，主动地控制他转换成String/Number类型时的值。

~~~
var foo = {};
foo == foo.toString();//true
foo == foo.valueOf();//true
~~~

而!=相当于==的结果取反。

# How和What

网络上关于ES比较运算的描述更加详尽，有人乐此不疲统计着各种各样的情况，甚至还画出一个巨大的关系图。

作为猎奇是很有趣的，作为学习我则是十分不推崇这种方法。

甚至是上文的结论一二三，阅读他可以辅助我理解===的比较方式，记忆他却会成为障碍。

一样东西，因为他是什么，所以才有他的行为。
并不是他有了那些行为，他才是那样的东西。
描述怎么的（How）往往要比描述是什么（What）要繁琐得多。

**而且，程序语言是一门完备的科学，不需要用统计的方法去进行黑盒测试！**

# 不提供解决问题的方法

此节是本篇多次增删后得出的结论。